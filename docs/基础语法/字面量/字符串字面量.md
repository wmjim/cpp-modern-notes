# 字符串字面量

#左值

## 语法

C++ 定义了多种字符串字面量语法，不同前缀表示不同编码/类型：

| 语法                       | 类型                     | 说明               |
| ------------------------ | ---------------------- | ---------------- |
| ​​`"text"`​              | ​​`const char[N]`​     | 普通字符串字面量         |
| ​​`L"text"​`             | ​​`const wchar_t[N]`​  | 宽字符字符串           |
| `​​u8"text"​`            | ​​-​                   | UTF-8 字面量 #cpp20 |
| `​​u"text"`​             | `​​const char16_t[N]`​ | UTF-16 字面量       |
| `​​U"text"`​             | `​​const char32_t[N]`​ | UTF-32 字面量       |
| `​​R"(text)"`​           | `​​const char[N]​`     | 原始字符串字面量（不转义）    |
| `​​R"delim(text)delim"`​ | `​​const char[N]`​     | 带自定义分隔符的原始字符串    |
| `​​"a" "b"​`             | `​​const char[N]​`     | 编译期自动拼接          |

- **类型安全**​：禁止将普通字面量赋值给 `char*`​，应使用 `const char*` #cpp11 ​
- `u8`：在 #cpp20 前是 `const char[N]`，之后是 `const char8_t[N]`
- **宽字符慎用**：`wchar_t` 编码依赖平台，跨平台场景优先使用 `UTF` 系列。

## 示例

```cpp
// 普通字面量
const char* s1 = "hello";

// 原始字符串（适合正则、路径）
const char* s2 = R"(C:\path\file.txt)";
const char* s3 = R"json({"key": "value"})json";

// UTF-8 字面量
const char* s4 = u8"你好";

// 空白分隔字符串常量自动拼接
char s5[] = "he" "llo";

// 自定义后缀（需 using 命名空间）
using namespace std::string_literals;
auto s6 = "hello"s;   // std::string
auto s7 = "hello"sv;  // std::string_view
```


## 原始字符串字面量

```cpp
R"delimiter( 内容 )delimiter"

const char* s1 = R"foo(
Hello
  World
)foo";
```

```bash

Hello
  World
```

- 使用 `R` 作为前缀
- 不对内部字符进行转义处理
- 以自定义定界符 `delimiter` 包围正文
- 定界符匹配严格一致，否则编译错误
- 原始形式便于包含反斜杠、引号、换行等内容

## 初始化行为

字符串字面量生成的对象初始化规则：

1. 按与字面量对应的编码对字符序列进行编码。
2. 转义序列（数字转义、条件转义等）会映射到相应码元。
3. 最后自动附加空字符 (`U+0000`) 表示结束。