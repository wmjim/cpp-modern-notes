# 多态

<mark>**多态**</mark>：同一接口表现出不同的行为。

## 两种多态

### 编译时多态（静态多态）

通过 **函数重载** 和 **模板** 实现，在编译时确定调用哪个函数。

```cpp
// 函数重载
void print(int x) { cout << x << endl; }
void print(double x) { cout << x << endl; }
void print(const string& s) { cout << s << endl; }

print(42);      // 调用 print(int)
print(3.14);    // 调用 print(double)
print("hello"); // 调用 print(string)

// 模板
template<typename T>
void print(const T& x) { cout << x << endl; }

print(42);      // T = int
print(3.14);    // T = double
```

### 运行时多态（动态多态）

通过 **虚函数** 和 **继承** 实现，在运行时根据实际对象类型决定调用哪个函数。

```cpp
class Animal {
public:
    virtual void speak() const {
        cout << "动物在说话！" << endl;
    }
    virtual ~Animal() = default;
};

class Dog : public Animal {
public:
    void speak() const override {
        cout << "狗在说话！" << endl;
    }    
};

class Cat : public Animal {
public:
    void speak() const override {
        cout << "猫在说话！" << endl;
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->speak();    // 输出：狗在说话！
    a2->speak();    // 输出：猫在说话！

    delete a1;
    delete a2;
}
```

![](https://raw.githubusercontent.com/wmjim/blogimages/main/20260227064335415.png)

**运行时多态的关键要素：**

1. **基类声明虚函数**：使用 `virtual` 关键字
2. **派生类重写函数**：用相同签名覆盖基类实现
3. **通过基类指针/引用调用**：运行时决定具体调用哪个版本